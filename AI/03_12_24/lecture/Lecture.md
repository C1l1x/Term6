1. Съставните части, на които може да разбием един такъв проблем:
    - Начален възел
    - Функция, която връща съседите на зададен възел, използвайки списък от дъгите, излизащи от възела
    - Функция, която връща булев резултат дали достигнатият възел е крайният (нашата цел)
    - (не задължително) Евристична функция, която връща позитивно реално число. Нейната стойност по подразбиране е 0.

2. Дефиниране
    - raise NotImplementedError() е начин, по който да дефинираме абстрактен метод, който трябва да се пренапише (override) и да се дефинира същността на проблема за търсене.
    - Съседите са всъщност списък от дъги. Насочената дъга има в себе си FROM и TO възли, които са двойка възли. Може да съдържа и позитивно реално число (със стойност по подразбиране единица), като тогава дъгата се означава като „действие“


<!-- 
class Search_problem(object):
    """Проблемът се състои от:
    * начален възел
    * съседна функция, която връща съседите на даден възел
    * спецификация на целта
    * (допълнително) евристична функция
    Методите трябва да се пренапишат, за да се дефинира проблема."""
    
    def start_node(self):
    """връща началния възел"""
    raise NotImplementedError("start_node") # abstract method
    
    def is_goal(self,node):
    """връща True ако възела е този, който търсим"""
    raise NotImplementedError("is_goal") # abstract method
    
    def neighbors(self,node):
    """връща списък от дъгите, излизащи от текущия възел"""
    raise NotImplementedError("neighbors") # abstract method
    
    def heuristic(self,n):
    """Евристична функция, която връща позитивно реално число.
    Нейната стойност по подразбиране е 0."""
    return 0 
-->
![Code PNG](image.png)

<!-- 
class Arc(object):
    """Насочената дъга има в себе си FROM и TO възли, които са двойка възли. Може да съдържа и позитивно реално число """
    def __init__(self, from_node, to_node, cost=1, action=None):
    assert cost >= 0, ("Cost cannot be negative for"+
    str(from_node)+"->"+str(to_node)+", cost:
    tr(cost))
    self.from_node = from_node
    self.to_node = to_node
    self.action = action
    self.cost=cost
    
    def __repr__(self):
    """string representation of an arc"""
    if self.action:
    return str(self.from_node)+" --"+str(self.action)+"--
    tr(self.to_node)
    else:
    return str(self.from_node)+" -- "+str(self.to_node)
-->

![Code png](image-1.png)

3. Представяне на граф при търсене
    - Представянето на граф при решението на проблем с търсене започва с вече дефиниран граф (а не такъв, който се генерира при необходимост). Той се състои от:
        > Списък от възли
        > Списък от дъги
        > Начален възел
        > Списък от възлите решение (или целта, към която се стремим)
        > (допълнително) речник, който указва евристичната стойност на всеки възел
    - За да дефинираме проблема, дефинираме началния възел, целта, съседската функция и евристичната функция
    
    
    can i commit